FULL-STACK-BLOG

<h2>backend</h2>

- [x] Node.js
- [x] Express.js + Validator
- [x] MongoDB / Mongoose
- [x] JSON Web Token
- [x] Multer
- [x] BCrypt

<br>

<h2>frontend</h2>

- [x] ReactJS
- [x] Redux Toolkit
- [x] React Hook Form
- [x] React Router
- [x] React Markdown / Simple Editor
- [x] Axios

# ОСОБО НЕПОНЯТНОЕ ПИШУ ТУТ
- [x] ПРО ССЫЛКИ В MONGODB - как формируются коллекции и как подулючится не к кластеру а конкретно к БД 50 МИНУТА В РОЛИКЕ
- [x] Как монго на основе модели формирует папки САМА 50:17
- [x] Зачем поместили _id в jwt токен и для чего он? 54:30
- [x] ПРО next() в middlewear и сам middlewear
  
- [x] Расписать подробнее про связи в mongoose mongoose.Schema.Types.ObjectId, ref, и тд
- [x] .populate("user").exec(); $push $pull и как поле отображает данные не в id а как подробные данные на основе связей.
- [x] Транзакции в MongoDB (Есть в любой бд!!) Важно! (Атомарная операция)

<br>
<br>
<hr>

# BACKEND

<h2>РЕГИСТРАЦИЯ </h2>

<h3>+ JWT-token</h3>

- [ ] Генерируем токен, с которым можно в дальнейшем обращаться к защищенным запросам в приложении. Например -
- [ ] С помощью токена приложение понимает - авторизован-ли пользователь / может ли что-то создавать (статьи)
- [ ] На его основе будет дальнейшая регистрация/авторизация.

```javascript
// В ответе формируется token при помощи jwt.sign()
// Он содержит объект с данными из тела запроса, которые будут зашифрованы
app.post("/auth/login", (req, res) => {
  const token = jwt.sign(
    {
      email: req.body.email,
      password: req.body.password,
    },
    "secret123"
  );

// Это ответ от сервера
  res.json({
    succees: true,
    data: {
      userName: req.body.name,
      surname: req.body.surname,
    },
    token,
  });
});
```

+ это секретный ключ, который используется для подписи и проверки подлинности токена. Этот ключ должен быть известен только серверу, чтобы нельзя было подделать или изменить токен.
+ Любой может быть

<br>
<hr>

<h3>+ Создание модели user / UserModal / Mongo DB</h3>

- [x] **`Модель (Model) Mongoose`** - это конструктор, который позволяет создавать экземпляры документов на основе **`схемы`**. Модели предоставляют методы для создания, чтения, обновления и удаления документов в коллекции MongoDB.
- [x] **`Схема (Schema) Mongoose`** - это описание структуры документов, которые будут храниться в MongoDB коллекции. Схемы определяют поля, их типы данных, допустимые значения и другие ограничения для документов в коллекции.

```javascript
import mongoose from "mongoose";

// Схема user
// Все св-ва для user
// Это объект с описанием всех свойств пользователя

// Например:
//  1) type - тип поля
//  2) required - поле обязательно

//  3) unique - поле должно быть уникально
//      ЭТО ПОЛЕ СОЗДАЕТ ИНДЕКС УНИКАЛЬНОСТИ В MONGO
//      И ПРИ СОВПАДЕНИИ ПАРАМЕТРА - MONGO БУДЕТ ВЫДАВАТЬ ОШИБКУ
// Их больше

//  4) User будет хранить в себе список постов, которые он создал поэтому нужна связь
//  Связь с другими объектами:
//      а) type - mongoose.Schema.Types.ObjectId (id того, с чем будет связть)
//      б) ref - на какую сущность ссылка (тут сущность Post - PostModel)
//  + Тут это массив постов, поэтому оборачиваем в [], как массив объектов
const UserSchema = new mongoose.Schema(
  {
    fullName: {
      type: String,
      required: true,
      unique: true,
    },
    surname: {
      type: String,
      required: true,
    },
    email: {
      type: String,
      required: true,
      unique: true,
    },
    passwordHash: {
      type: String,
      required: true,
    },
    // У пользователя будут данные о его созданных постах (массив постов)
    // Для этого указываем тип (из монго) и ref (на что ссылается - т.е. связь)
    posts: [{ type: mongoose.Schema.Types.ObjectId, ref: "Post" }],
    avatarUrl: String,
  },
  //  4) timestamps - автосоздание даты
  {
    timestamps: true,
  }
);

// Экспортируем модель, где:
//  1) mongoose.model() - сам метод с аргументами:
//      а) Имя модели.
//      б) Схема этой модели.
// ПРИ ИМПОРТЕ ПО DEFAULT - МОЖЕТ ИМЕТЬ ЛЮБОЕ ИМЯ
// Тут оно будет UserModel
export default mongoose.model("User", UserSchema);
```

<br>
<hr>

<h3>+ Валидация / Express Validator</h3>

Перед тем, как делать запрос и тд, нужно сделать валидацию, чтобы проверить корректность информации при помощи **`Express Validator`**, он представляет множество методов для валидации разных данных, приходящих в теле запроса.

- [x] Библиотека **`Express Validator`** предоставляет различные методы для валидации данных, отправляемых или получаемых через **`HTTP запросы в приложении Express.js`**.

+ Создается папка validations, где будут файлы валидации под разные данные.

```javascript
// Импортируем метод для валидации данных в теле запроса body()
// body() используется для валидации данных, переданных в теле HTTP-запроса, обычно в формате JSON или URL-кодированных данных.
import { body } from "express-validator";

// Создаем массив с полями + сообщением и прописываем опции
// Опции типа дллина, обязательность и тд их можно посмотреть в сети
export const registerValidation = [
  body("email", "Неверный формат почты").isEmail(),
  body("password", "Пароль должен быть от 5 символов").isLength({ min: 5 }),
  body("fullName", "Укажите имя").isLength({ min: 3 }),
  body("avatarUrl", "Неверная ссылка на аватарку").optional().isURL(),
];
```

<br>

+ Валидация используется в качестве второго(необязательного) аргумента в функции запроса к серверу.

```javascript
// Импорт созданной валидации
// И метода который проверяет результат валидации
import { registerValidation } from "./validations/auth.validation.js";
import { validationResult } from "express-validator";

// Post запрос где как раз:
//  1) Роут
//  2) Валидация(созданная) (не обязательно - может быть что угодно или ничего)
//  3) callback
app.post("/auth/register", registerValidation, async (req, res) => {
// Объявл. перменная error, где методом validationResult(req) будет проверяться тело запроса
// Результат - переменная error - это объект с ошибкой
  const errors = validationResult(req);

// Проверяем - метод isEmpty() у error:
//  true - ошибки нет
//  false - ошибка есть и надо обработать
  if (!errors.isEmpty()) {
    return res.status(400).json(errors.array());
  }
// ... запрос далее
});
```

<br>
<hr>

<h3>+ bcrypt</h3>

Важная часть для защиты данных - это шифрование. Например шифрование паролей. Для этого используется библиотека **`bcrypt`**. Шаги:

`ВАЖНО, ЧТО ДЕЙСТВИЯ С СОЗДАНИЕМ СОЛИ И ШИФРОВАНИЯ ЗАНИМАЮТ ВРЕМЯ - ПОЭТОМУ ЭТИ МЕТОДЫ АСИНХРОННЫЕ!!!! ASYNC \ AWAIT`

- [x] **Генерация соли**:

+ **`Соль`** – это случайная строка, которая добавляется к паролю перед хэшированием. Это обеспечивает уникальность хэша для одинаковых паролей и предотвращает использование таблиц радужных хэшей (rainbow tables) для подбора паролей.

+ Для генерации **`соли`** используется метод **`genSalt()`** из библиотеки **`bcrypt`**. Она принимает один аргумент – количество "раундов" (или итераций) хэширования. Чем больше раундов, тем безопаснее, но и медленнее будет происходить хэширование. Обычно используются значения от **`10 до 12`**.

<br>

- [x] Хэширование пароля:

+ После того как у вас есть соль, вы можете хэшировать пароль с использованием функции **`hash()`**. Эта функция принимает два аргумента: пароль и соль.

<br>

- [x] Проверка пароля:

+ При аутентификации пользователей в приложении, вы должны проверять, совпадает ли введенный пароль с хэшированным паролем в базе данных. Для этого используйте функцию **`compare()`**. Она сравнивает введенный пароль с хэшированным паролем и возвращает **`true`**, если они совпадают, или **`false`**, если нет.

`ПРИМЕР ПРОВЕРКИ`
```javascript
const enteredPassword = 'userEnteredPassword';
const passwordMatch = await bcrypt.compare(enteredPassword, hashedPassword);

if (passwordMatch) {
  // Пароль верный, продолжаем аутентификацию
} else {
  // Пароль не верный, отказываем в доступе
}
```

`НАШ КОД`

```javascript
import bcrypt from "bcrypt";

  // Создаем переменную с паролем из req.body
  // Генерируем соль - bcrypt.genSalt(10);
  // Создаем переменную, в которой будет зашифрованный пароль - bcrypt.hash()

  // Теперь в переменной passwordHash находится зашифрованный пароль
  // Он и будет сохранен в базу данных. 
  const password = req.body.password;
  const salt = await bcrypt.genSalt(10);
  const passwordHash = await bcrypt.hash(password, salt);
```

<br>
<hr>

<h3>+ Создание пользователя в БД </h3>

- [x] На основе описанной модели **`UserModel`** для `user` - мы создаем пользователя в базе данных при **`post-запросе`**.

```javascript
// Сначала импортируем модель
import UserModel from "./models/User.js";

  // Тут на основе модели UserModel подготавливаем объект пользователя для БД
  // ВАЖНО, что поля должны соответствовать описанным в МОДЕЛИ
  // В кач-ве ключей подставляем значения из req.body(тело запроса) кроме пароля
  // Пароль подставляется уже зашифрованный
  const userData = new UserModel({
    email: req.body.email,
    fullName: req.body.fullName,
    passwordHash: passwordHash,
    avatarUrl: req.body.avatarUrl,
  });

  // Сохраняем пользователя в MongoDB методом save()
  // Результат, который вернет Mongo помещаем в user и его возвращаем в ответе в JSON - формате
  const user = await userData.save();
  res.json(user);

  // МОЖНО ПРОМИСОМ
  // userData
  //   .save()
  //   .then((userData) => res.status(200).json(userData))
  //   .catch((error) => console.log(error));
``` 

<br>
<hr>

<h3>+ Создание пользователя в БД - ИТОГ: </h3>

- [x] Метод по роуту `/auth/register` будет отправлять `post-запрос` на добавление пользователя в БД (регистрация)
- [x] Кратко:

+ Точный роут + прописанныя валидация, которая проверяет тело запроса.
+ Блок `try \ catch` для отлова потенциальных ошибок + сразу прописан блок `catch`
+ Создадим переменную `error` и методом `validationResult(req)` из библиотеки `Express Validation` выявим мохможные ошибки. + Далее методом `isEmpty()` в конструкции `if` проверим наличие ошибок.
+ Достаем пароль из тела запроса и шифруем его
+ На основи модели `UserModel` создаем пользователя используя данные из запроса + шифрованый пароль.
+ `const user = await newUser.save()` - создаем объёкт в базе данных а в `user` помещаем информацию о нем.
+ Шифруем _id при помощи jwt
+ Возвращаем данные на клиент. Деструктуризацией + spread можно вернуть конкретные данные или не возвращать как напримере зашифрованного пароля, тк при регистрации это инфа не нужна.

```javascript
// РЕГИСТРАЦИЯ
app.post("/auth/register", registerValidation, async (req, res) => {
  try {
    const errors = validationResult(req);

    if (!errors.isEmpty()) {
      return res.status(400).json(errors.array());
    }

    // Создаем переменную с паролем из req.body
    // Генерируем соль - bcrypt.genSalt(10);
    // Создаем переменную, в которой будет зашифрованный пароль - bcrypt.hash()

    // Теперь в переменной passwordHash находится зашифрованный пароль
    // Он и будет сохранен в базу данных.
    const password = req.body.password;
    const salt = await bcrypt.genSalt(10);
    const passHash = await bcrypt.hash(password, salt);

    // Тут на основе модели UserModel подготавливаем объект пользователя для БД
    // ВАЖНО, что поля должны соответствовать описанным в МОДЕЛИ
    // В кач-ве ключей подставляем значения из req.body(тело запроса) кроме пароля
    // Пароль подставляется уже зашифрованный
    const newUser = new UserModel({
      email: req.body.email,
      fullName: req.body.fullName,
      passwordHash: passHash,
      avatarUrl: req.body.avatarUrl,
    });

    // Сохраняем пользователя в MongoDB методом save() ASYNC
    // Результат, который вернет Mongo помещаем в user и его возвращаем в ответе
    // Теперь в user лежит объект с данными и кучей методов из БД
    const user = await newUser.save();

    // Зашифрованный id, чтобы потом узнать авторизован ли пользователь
    // После того как расшифруем токен его
    // !!! ПОКА НЕ ЯСНО КАК И ЗАЧЕМ ЭТО !!!
    const token = jwt.sign(
      {
        _id: user._id,
      },
      "secret123",
      {
        expiresIn: "30d",
      }
    );

    // Сам объект user содержит в себе кучу методов и св-в, если вывести {...user}
    // Но если мы не хотим что то возвращать на клиент, например пароль
    // То из _doc деструктуризацией достаем пароль и остальные данные spread
    // в _doc как раз лежат данные пользователя (которые отправили как описано в модели)
    const { passwordHash, ...userData } = user._doc;

    // А на клиент возвращаем эти данные без пароля + токен
    res.json({ ...userData, token });

    // Обрабатываем ошибку - вернем на клиент статус и инфо
  } catch (error) {
    console.log(error);
    res.status(400).json({
      status: 400,
      message: "Не удалось зарегистрироваться",
    });
  }
});
```

<br>
<br>
<hr>

<h2>АВТОРИЗАЦИЯ </h2>

- [x] Когда мы делаем авторизацию - мы хотим найти пользователя. Т.е понять есть ли он в базе данных.
- [x] Кратко:

+ Нужно понять есть ли пользователь в базе по имени или имейлу. Используя модель **`UserModel (помним, что она описывает пользователя)`** и метод  **`findOne()`**, с заданными параметрами (а именно `email`), который будет искать объект в базу ореинтируясь на схожий параметр в **`req.body.email`**. Если ок - то в **`user`** будет инфа об этом объекте в базе `помним ту дрочь с огромным объектом который получается в {...user}` (там еще есть `_doc`) и идем дальше. Если не ок то ошибка.
+ Далее проверка введенного пароля при помощи метода **`compare()`** в **`bcrypt`**, который принимает аргументом пароль, из **`req.body.password`** и пароль, полученный из найденного объекта в переменной `user`. Пароль расшифровывается и сравнивается с введенным в теле запроса.
+ Далее `_id` в токен `НЕПОНЯТНО ДОПИСАТЬ`
+ Как и в регистрации - возвращаем данные из того огромного `{...user._doc}` и возвращаем данные юзера кроме шифрованного пароля. (он только для авторизации)
+ При ошибке выведем ошибку при авторизации

<br>
<hr>

<h3>+ Код</h3>

- [x] Код аналогичен с регистрацией + есть комменты.

```javascript
// АВТОРИЗАЦИЯ
app.post("/auth/login", async (req, res) => {
  try {
    // Сначала мы находим пользователя в БД по описаным параметрам
    // Используем модель UserModel и метод findOne() с параметром email
    // Если email из req.body есть в БД то идем дальше или ошибка.
    // Если email такой есть - то в user будет информация об этом пользователе (знакомый {...user})
    const user = await UserModel.findOne({ email: req.body.email });

    // если такого user нет - останавливаем и возвращаем сообщение
    if (!user) {
      return res.status(400).json({
        message: "Неверный логин или пароль",
      });
    }

    // После нужно понять - верный ли введен пароль
    // Перменная в которой будет булиновое значение
    // Используем метод compare() у bcrypt, где мы передаем два аргумента:
    //    1) Введенный пароль из тела запроса - (req.body.password)
    //    2) Зашифрованный пароль из объекта в БД ({...user}), который найден по email
    //        и объекта _doc с данными в нем. (В том числе и зашифрованный пароль)
    // Метод compare() расшифрует пароль и сравнит с введенным
    const isValidPass = await bcrypt.compare(
      req.body.password,
      user._doc.passwordHash
    );

    // Если пароль не совпали - false - то ошибка
    if (!isValidPass) {
      return res.status(400).json({
        message: "Неверный логин или пароль",
      });
    }

    // Шифруем опять _id - неясно повторить
    const token = jwt.sign(
      {
        _id: user._id,
      },
      "secret123",
      {
        expiresIn: "30d",
      }
    );

    // Так же как и при регистрации - возвращаем на клиент данные о пользователе
    // Кроме зашифрованного пароля + токен
    const { passwordHash, ...userData } = user._doc;

    res.json({ ...userData, token });
  } catch (error) {
    // Ошибка авторизации
    console.log(error);
    res.status(400).json({
      message: "Не удалось авторизоваться",
    });
  }
});
```

<br>
<br>
<hr>

<h2>ПОЛУЧЕНИЕ ИНФОРМАЦИИ О ПРОФИЛЕ (ЗАРЕГЕСТРИРОВАН ИЛИ НЕТ?)</h2>

- [x] Задача состоит в том, чтобы понять - есть ли у пользователя доступ к защищенной информации, которая доступна только зарегестрированному пользователю, или нет. Для определения этого используется `JWT Token`. Подробнее:

+ Когда пользователь `регистрируется / авторизуется` - он получает от сервера `JWT Token`, в котором зашифрован его `_id` в базе данных (при помощи секретного ключа). Этого должно быть достаточно, чтобы понять авторизован он или нет.
+ Когда пользователь хочет получить доступ к защищенным данным, он должен отправить в `header` своего запроса его токен, который лежит в `localstorage`.
+ На этом этапе сервер должен понять - был ли передан токен, а так же является ли он действительным. 
+ Напишем `**middleware**`, который будет проверять по токену (который мы везде шифровали) - имеет ли пользователь доступ (авторизован ли он). Так же имеет ли пользователь по расшифрованному токену выполнять какие - либо действия. (Например получать информацию о себе)
+ Если все ОК - то `middleware` пропускает запрос дальше и выполняем нужные действия. Если не ОК - то получим какую-то ошибку

<br>
<hr>

<h3>+ Проверка на авторизацию (middleware)</h3>

- [x] Т.Е. АВТОРИЗОВАН ЛИ ПОЛЬЗОВАТЕЛЬ СЕЙЧАС ИЛИ НЕТ
- [x] Напишмем `middeleware`, который будет определять по токену - можно ли возврощать какую-либо информацию пользователю или нельзя (в отдельной дериктории).
- [x] На этом этапе `middleware` перехватывает запрос и проверяет наличие / действительность токена. Если ок - можно что-то делать, нет - нет доступа

```javascript
import jwt from "jsonwebtoken";

// middleware - 3 параметра:
//    1) req - это запрос, который он перехватил
//    2) res - ответ
//    3) next() - middleware закончил и передает работу дальше
export default (req, res, next) => {
  // Проверяем есть ли в запросе токен
  // Он всегда передается в headers.authorization  запросе
  // + убираем прикиску Bearer, которая передается всегда
  const token = (req.headers.authorization || "").replace(/Bearer\s?/, "");

  // Если токен есть - то его нужно декодировать
  // Затем "ВШИТЬ" в тело запроса. Там появится новое св-во userId
  if (token) {
    try {
      // Декодируем токен и помещаем сюда его содержимое при помощи секретного ключа
      // (ключ который был при шифровании при авторизации / логгир)
      // (там _id, которое шифруется при log или auth)
      const decoded = jwt.verify(token, "secret123");

      // Вшиваем userId в запрос req
      req.userId = decoded._id;

      // Передаем дальше действи (middleware закончен)
      next();
      // или нет доступа (если токен не верен)
    } catch (error) {
      res.status(403).json({
        message: "Нет доступа",
      });
    }
    // ошибка (если токен не передан)
  } else {
    res.status(403).json({
      message: "Нет доступа",
    });
  }
};
``` 

<br>
<hr>

<h3>+ Получение информации о пользователе</h3>

- [x] Как только `middleware` отработал успешно - он передает выполнение фенкции дальше. Она уже выполнит поиск пользователя и вывелет данные о нем.

+ На основе модели `UserModel` ищем пользователя по id методом `findById()`, как аргумент указал `userId`, который мы вшили в запрос в `middleware`.
+ Если найден пользователь - выводим данные о нем из `user._doc`

- [ ] ПРИМ. Когда мы получаем данные о пользователе - мы хотим видеть какие посты он создавал. Изначально в списке `posts` будут содержаться `objectId` этих постов. Если какое то поле в объект у нас ссылается на другой документ (например поле `posts` у пользователя ссылается на документ `Post`, который описан в `PostModel`) и мы хотим вместо `objectId` этих постов видеть само содержимое, то `mongoose` предоставляет метод `populate()`, который заполняет поля конкретными данными. Конечно при условии если установлена связь. Связи устанавливаются непосредственно в описании моделей.

+ ПРИМЕР - модель `UserModel` => поле `posts` => `ref` - устанавливает связь с документов (`Post` например). А `Post` - это отдельная модель в БД
+ При этом особый тип `mongoose.Schema.Types.ObjectId` - говорит, что тут будет содержаться `id` из другой коллекции и будет связь
+ + тут массив и поэтому обернули в `[]`. 

```javascript
    // У пользователя будут данные о его созданных постах (массив постов)
    // Для этого указываем тип (из монго) и ref (на что ссылается - т.е. связь)
    posts: [{ type: mongoose.Schema.Types.ObjectId, ref: "Post" }],
```

```javascript
//    1) роут
//    2) midleware
//    3) функция
app.get("/auth/me", checkAuths, async (req, res) => {
  try {
    // Ищем пользвателя по userId,
    // Его мы вшили в req на этапе middleware
    // Информация о пользователе помещаем в user
    // Метод populate() - позволяет вместо id (чего-то) вывести конкретные данные
    // В данном случае - это будут посты пользователя 
    const user = await UserModel.findById(req.userId).populate("posts");

    // User не найден - ошибка
    if (!user) {
      res.status(404).json({
        message: "Пользователь не найден",
      });
    }

    // User найден - достаем все кроме пароля и отдаем на клиент
    // из user._doc
    const { passwordHash, ...userData } = user._doc;

    res.json({ ...userData });
    // Ошибка, если в запросе что-то не так
  } catch (error) {
    console.log(error);
    res.status(400).json({
      status: 400,
      message: "Нет доступа",
    });
  }
});
```

- [x] Как итог - этот запрос будет говорить - авторизован пользователь или нет. И благодаря ему в react-приложении мы сможем показать информацию о профиле и тд.

<br>
<br>
<hr>

<h2>CRUD-ОПЕРАЦИЙ / ПОСТЫ </h2>

- [x] Прежде чем писать функционал `crud-операций`, стоит сначала создать модель, которая будет описывать посты в базе данных.
- [x] Тут уделяется особое внимание созданию связи между объектами `mongoose.Schema.Types.ObjectId`  

```javascript
const PostSchema = new mongoose.Schema(
  {
    title: {
      type: String,
      required: true,
    },
    // Автор / создатель статьи - это пользователь и он должен отображаться тут
    //   1) type -В user мы должны хранить id пользователя.
    // Но в mongo это не просто строчка, а ObjectId
    // поэтому указываем специальный тип (по пути)
    //    (это один из спец. типов внутри mongodb)
    //   2) ref - св-во user ссылается на модель (тут User)
    //    (т.е делаем связь между двумя таблицами)
    //   3) Обязательное
    user: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "User",
      required: true,
    },
    text: {
      type: String,
      required: true,
    },
    tags: {
      type: Array,
      default: [],
    },
    viewsCount: {
      type: Number,
      default: 0,
    },
    imageUrl: String,
  },
  {
    timestamps: true,
  }
);

export default mongoose.model("Post", PostSchema);

```

<br>
<hr>

<h3>+ Создание поста</h3>

- [x] ПРИМ. Тут используется подход `атомарности`, при котором запрос на создание либо выполняется полностью, либо не выполняется совсем. Это позволяет избежать багов, при которых у нас может быть создан в базе данных, но при этом не будет создан у пользователя. Либо он будет создан как надо либо не будет создан вообще нигде и => ошибка.
- [x] Для этого используется подход `сессий и транзакций`. 

```javascript
// Создание поста
const create = async (req, res) => {
  // Первым делом нужно создать сессии и запустить её (асинхронная!)
  // Чтобы обеспечить атомарность операции
  const createPostSession = await mongoose.startSession();
  createPostSession.startTransaction();

  // На основе пост модели создаем новый пост из данных запроса
  try {
    const newPost = new PostModel({
      title: req.body.title,
      text: req.body.text,
      imageUrl: req.body.imageUrl,
      tags: req.body.tags,
      user: req.userId,
    });

    // Сохраняем пост в БД + помещаем его в переменную post(чтобы вернуть)
    //  + сначала сохраняем в сессии { createPostSession }
    const post = await newPost.save({ createPostSession });

    // Используя модель UserModel мы добавим пост в объект автора поста
    // Находим юзера в базе по userId(из токена) и обновляем его
    // $push (опция) - добавит данные в массив, без обновления всего массива
    // Теперь получая данные о юзере мы видем id всех его постов
    //  + указываем, что это происходит в сессии createPostSession
    await UserModel.findByIdAndUpdate(
      req.userId,
      { $push: { posts: post._id } },
      { new: true }
    ).session(createPostSession);

    // Если не произошло ошибок - фиксируем операции что были в сессии - commitTransaction()
    // и завершаем сессию (коммит АСИНХРОННЫЙ)
    await createPostSession.commitTransaction();
    createPostSession.endSession();

    // ернем созданный пост на клиент
    res.json(post);
  } catch (error) {
    // В случае ошибки отменяем все действия в сессии abortTransaction() + завершаем
    await createPostSession.abortTransaction();
    createPostSession.endSession();

    // обработка ошибки
    console.log(error);
    res.status(400).json({
      status: 400,
      message: "Не удалось создать пост",
    });
  }
};
```

<br>
<hr>

<h3>+ Удаление поста</h3>

- [x] Удаление происходит аналогично. Используем подход `атомарности`, чтобы удалить пост и из бд и у пользователя.

```javascript
// Удаление поста
// Аналогичный подход с транзакциями
const remove = async (req, res) => {
  const deletePostSession = await mongoose.startSession();
  deletePostSession.startTransaction();

  try {
    // Удаление поста происходит по его id
    // Он подставляется в url динамически и достается из req.params.id
    const postId = req.params.id;

    // На основе модели PostModel находим пост по id и удаляем его
    // + сохраняем рещультат в переменную и указываем сессию
    const deletedPost = await PostModel.findByIdAndDelete(postId).session(
      deletePostSession
    );

    // Если переменная false - пост не найден - то ошибка
    if (!deletedPost) {
      return res.status(404).json({
        message: "Статья не найдена",
      });
    }

    // Если ок то далее удаляем пост у пользователя по его ID
    // Его ID получен из middleware, который расшифровывает токен
    // и из токена получаем id авторизованного пользователя в данный момент
    // $pull удалит из массива posts объект c objectId - postId (получен выше из url)
    //  + указываем что это в сессии
    await UserModel.findByIdAndUpdate(
      req.userId,
      { $pull: { posts: postId } },
      { new: true }
    ).session(deletePostSession);

    // Все ок - фиксируем операции в сессии commitTransaction() + завершаем
    await deletePostSession.commitTransaction();
    deletePostSession.endSession();

    // пост удален
    res.json({
      message: "Пост удален",
    });
  } catch (err) {
    // ошибка - отменяем транзакцию + завершаем сессию
    await deletePostSession.abortTransaction();
    deletePostSession.endSession();

    // ошибки
    console.log(err);
    res.status(500).json({
      message: "Не удалось удалить статью",
    });
  }
};
```

<br>
<hr>

<h3>+ Получение постов Все\Один</h3>

- [x] Получение всех постов ничего сложного - запрос на роут - выдать все зарпосы методо find()
- [x] Используем метод `populate("user")`, и таким образм говорим, что поле `user` у поста связано с моделью `UserModel(мы использовали mongoose.Schema.Types.ObjectId для этого` и таким образов в поле `user` в ответе у объекта вместо `objectId` юзера будет весь объект пользователя из БД (его данные).

```javascript
// Получить все посты
const getAll = async (req, res) => {
  try {
    // Найти посты используя модель PostModel
    // populate("user") - говорим, что есть поле user
    // Тк есть связь с моделью User, то выдаст не id пользователя в поле user
    // а выдаст его полные данные
    const posts = await PostModel.find().populate("user").exec();

    // Вернуть все посты клиенту
    res.json(posts);
  } catch (error) {
    // Ошибка
    console.log(error);
    res.status(400).json({
      status: 400,
      message: "Не удалось получить посты",
    });
  }
};
```

<br>

- [x] Получение одного поста аналогичное, только нам нужно параллельно увеличить счетчик просмотров на посте дополнительно. Поэтому тут будет использоваться метод `findOneAndUpdate()`
- [x] Как итог - нам необходите найти статью и обновить ее счетчик просмотров на +1

```javascript
// Получение одного поста
const getOne = async (req, res) => {
  try {
    // Получается так же при помощи динамического id из запроса
    const postId = req.params.id;

    // Найти пост и обновить просмотри + поместить в переменную его
    //    1) указываем _id поста (из БД) который нужно найти (достали выше из запроса)
    //    2) $inc - инкрементирует значение { viewsCount: 1 } на еденице
    //    4) { new: true } - возвращает уже обновленные документ 
    //    3) populate("user") так же чтобы видеть данные о создателе
    const updateResult = await PostModel.findOneAndUpdate(
      { _id: postId },
      { $inc: { viewsCount: 1 } },
      { new: true }
    ).populate("user");

    // Если статьи не существует - ошибка
    if (!updateResult) {
      return res.status(404).json({
        message: "Статья не найдена",
      });
    }

    // В случае успеха возвращаем на клиент данные этой статьи
    res.json(updateResult);
  } catch (err) {
    // Ошибка
    console.log(err);
    res.status(500).json({
      message: "Не удалось получить статью",
    });
  }
};
```

<br>
<hr>

<h3>+ Обновление поста</h3>

- [x] Обновление происходит аналогично удалению / получению одного. Т.е. изменяем конкретный пост по его `id`, который достается из запроса `req.params.id`
- [x] ПРИМ. `Mongoose` обновлять будет только те поля, которые пришли в теле запроса `(title, text и тд)`. Т.е. остальные поля не будут тронуты, если в них ничего не пришло. Может возникнуть баг, при котором мы можем допустить на клиенте опечатку и вместо `text` отправить `text123`, и тогда `mongoose` проигнорирует это поле и не выдаст ошибку, якобы поля `text` небыло в запросе.
- [x] Поэтому при обновлении `mongoose` будет ссылаться на поля, описанные в модели `PostModel` и если соответствий нет - будет игнорирование без ошибка. 

```javascript
// Обновление поста
// Аналогично удалени / получению одного
const update = async (req, res) => {
  try {
    // Достаем id из запроса
    const postId = req.params.id;

    // Найти по id => обновить
    await PostModel.findByIdAndUpdate(
      // id gjcnf
      postId,
      {
        // Что обновить и на что
        title: req.body.title,
        text: req.body.text,
        imageUrl: req.body.imageUrl,
        tags: req.body.tags,
        user: req.userId,
      },
      // вернуть обновленный
      {
        new: true,
      }
    );

    // ОК!
    res.json({
      message: `Пост ${postId} изменен`,
    });
  } catch (error) {
    // Ошибка
    console.log(err);
    res.status(500).json({
      message: "Не удалось изменить статью",
    });
  }
};
```

<br>
<br>
<hr>

<h2>ЗАГРУЗКА ИЗОБРАЖЕНИЙ </h2>

